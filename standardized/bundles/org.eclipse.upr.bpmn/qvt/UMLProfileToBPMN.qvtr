
transformation UMLProfileBPMN2( uml :  UML, bpmnprofile : BPMNProfile, bpmn :  BPMN)
--QVTR transformation from UML model with UML Profile for BPMN 2 Processes applied to BPMN model.
{

--**********************************
--	Core Structure
--*********************************

top relation TopPackageToDefinitions
-- This relation maps BPMN Definitions to UML Package
-- checkonly semantics ensures there are no side effects in the BPMN model.
-- the enforce semantics ensures that a corresponding Definitions is created in the uml variable,
-- and the name is copied.
-- the where clause calls the subsequent relations to transform the contained elements.
{
	enforce domain bpmn _definitions : Definitions { };
	checkonly domain uml _package : uml::Package { };		
	where {
		DefinitionsToPackage( _definitions, _package );
		DefinitionsToProfile( _definitions, _package );
	}
}


relation PackageToDefinitions
--map Packages to Definitions
{ 
	enforce domain bpmn _definitions : Definitions{ 
		name  =  _name : String{},
		rootElement  =  _re : RootElement{ }
	};
	checkonly domain uml _package : uml::Package{ 
		name  =  _name,
		packageableElement  =  _pe : PackageableElement{ },
		profileApplication = _profileApplication : uml::ProfileAppication {
					appliedProfile = bpmnprofile }
	};
	--check stereotype
	checkonly domain uml _umlDefinition : bpmnprofile::Definition {
		base_Package  =  _package 
	};
	where { 
		PackageableElementToRootElement( _re, _pe ); 
	}
}


relation ProfileToDefinitions
--map Profile packages to Definitions
{ 
	enforce domain bpmn _definitions : Definitions { 
		name  =  _name : String{},
		rootElement  =  _re : RootElement{ }
	};
	checkonly domain uml _profile : uml::Profile{ 
		name  =  _name,
		packageableElement  =  _pe : PackageableElement{ },
		profileApplication = _profileApplication : uml::ProfileAppication {
				appliedProfile = bpmnprofile }
	};
	--check stereotype
	checkonly domain uml _umlDefinition : bpmnprofile::Definition{
		base_Package  =  _profile 
	};
	where { 
		PackageableElementToRootElement( _re, _pe ); 
	}
}


relation PackageablElementToRootElement
--map UML PackageableElement to BPMN RootElement
{ 
	_name : String;
	enforce domain bpmn _rootElement : RootElement{ 
		name = _name, 
		definition = _definition : Definition{} 
	};
	checkonly domain uml _packageableElement : uml::PackageableElement{
		name = _name,
		owningPackage = _package : Package{} 
	};
	--check stereotype
	checkonly domain uml _umlRootElement : bpmnprofile::RootElement {
		base_PackageableElement = _packageableElement 
	};
	when { 
		TopPackageToDefinitions( _definition, _package ); 
	}
	where { 
		CommentToDocumentation( _rootElement, _packageableElement ); 
		PackageImportToImport( _rootElement, _packageableElement );
		ActivityToProcess( _rootElement, _packageableElement );
		ActionToActivity( _rootElement, _packageableElement ); 
	}
}


relation CommentToDocumentation
--map UML Comment to BPMN Documentation
{ 
	enforce domain bpmn _documentation : Documentation { 
		name = _name : String{},
		textFormat = _textFormat: String{}, 
		text = _text: String{}
		--opposite( BaseElement.documentation ) = _baseElement : BaseElement{} 
	};
	checkonly domain uml _comment : uml::Comment { 
		name = _name, 
		body = _text
		--opposite( Element.ownedComment ) = _element : Element {}  
	};
	--check stereotype
	checkonly domain uml _umlDocumentation : bpmnprofile::BPMNDocumentation {
		base_Comment  =  _comment,
		textFormat  =  _textFormat 
	};
	when {
		ElementToBaseElement( _baseElement, _element );
	}
}


relation PackageImportToImport
--map UML PackageImport to BPMN Import 
{ 
	enforce domain bpmb _import : Import {
		importType = _importType : String{},
		location = _location : String{},
		namespace = _namespace : String{} 
	};
	checkonly domain uml _packageImport : uml::PackageImport {
		importedPackage = _package : Package {
										URI = _location,
										name = _namespace } 
	};
	--check stereotype
	checkonly domain uml _umlImport : bpmnprofile::Import {
		base_PackageImport = _packageImport
	};
}


relation OpaqueExpressionToExpression
--map UML OpaqueExpression to BPMN Expressopm 
{ 
	enforce domain bpmn _expression : Expression { 
		name = _name : String{} 
	};
	checkonly domain uml _opaqueExpression : uml::OpaqueExpression { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmnExpression : bpmnprofile::BPMNExpression {
		base_OpaqueExpression = _opaqueExpression 
	};
}


relation OpaqueExpressionToFormalExpression
--map UML OpaqueExpression to BPMN FormalExpressopm 
{ 
	enforce domain bpmn _formalExpression : FormalExpression { 
		name = _name: String{},
		evaluatestoTypeRef = _evaluatestoTypeRef: ItemDefinition {}
	};
	checkonly domain uml _opaqueExpression : uml::OpaqueExpression { 
		name = _name, 
		type = _class : uml::Class { } 
	};
	--check stereotype
	checkonly domain uml _umlFormalExpression : bpmnprofile::BPMNExpression {
		base_OpaqueExpression  =  _opaqueExpression
	};
	where {
		ClassToItemDefinition( _evaluatestoTypeRef, _class );  
	}
}


relation ClassToItemDefinition
--map UML Class to BPMN ItemDefinition 
{ 
	enforce domain bpmn _itemDefinition : ItemDefinition {
		name = _name : String{},
		itemKind = _itemKind : ItemKind,
		isCollection = _isCollection : Boolean 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlItemDefinition : bpmnprofile::ItemDefinition {
		base_Class = _class,
		itemKind = _itemKind,
		isCollection = _isCollection 
	};
}


relation DependencyToAssociation
--map UML Dependency to BPMN Association
{
	enforce domain bpmn _association : Association {
		name = _name : String{},
		sourceRef = _sourceRef : BaseElement,
		targetRef = _targetRef : BaseElement 
	};
	checkonly domain uml _dependency : Dependency {
		name = _name,
		client = _client : uml::Element,
		supplier = _supplier : uml::Element 
	};
	--check stereotype
	checkonly domain uml _umlAssociation : bpmnprofile::BPMNAssociation {
		base_Dependency = _dependency 
	};
	where {
		ElementToBaseElement( _sourceRef, _client );
		ElementToBaseElement( _targetRef, _supplier );
	}
}

relation StereotypeToExtension
--map UML Stereotype to BPMN Extension
{
	_extensionAttributeDefinition : ExtensionAttributeDefinition;
	enforce domain bpmn _extension : Extension { 
		name = _name : String{}, 
		opposite( Definitions.extensions ) = _definitions : Definitions,
		definition = _extensionDefinition : ExtensionDefinition {
			extensionAttributeDefinition =  _extensionAttributeDefinition } 
	};
	checkonly domain uml _stereotype : Stereotype { 
		name = _name,
		owningPackage = _package : Package { },
		ownedAttribute = _property : Property { } 
	};
	--check stereotype
	checkonly domain uml _umlExtension : bpmnprofile::BPMNExtension { 
		base_Stereotype = _stereotype,
		definition = _umlExtensionDefintion 
	};
	checkonly domain uml _umlExtensionDefintion : bpmnprofile::ExtensionDefinition {
		base_Stereotype = _stereotype 
	};
	where {
		PropertyToExtensionAttributeDefinition( _extensionAttributeDefinition, _property ); 
	}
	when {
		TopPackageToDefinitions( _definitions, _package );
	}
}


relation PropertyToExtensionAttributeDefinition
--map UML Property to BPMN ExtensionAttributeDefinition
{
	enforce domain bpmn _extensionAttributeDefinition : ExtensionAttributeDefinition { 
		name = _name : String{},
		type = _type : String{},
		isReference = _isReference : Boolean 
	};
	checkonly domain uml _property : Property { 
		name = _name,
		type = _umltype : uml::Class { qualifiedName = _type },
		isComposite = _isReference 
	};
	--check stereotype
	checkonly domain uml _bpmnExtensionAttributeDefinition : 
									bpmnprofile::ExtensionAttributeDefinition { 
		base_Property = _property 
	};
}



relation SlotToExtensionAttributeValue
--map UML Slot to BPMN ExtensionAttributeValue
{
	enforce domain bpmn _extensionAttributeValue : ExtensionAttributeValue {
		name = _name : String{},
		extensionAttributeDefinition = _extensionAttributeDefinition 
					: ExtensionAttributeDefinition,
		opposite( BaseElement.extensionValues ) = _baseElement : BaseElement 
	};
	checkonly domain uml _slot : Slot { 
		name = _name,
		owningInstance = _owningInstance : uml::InstanceSpecification {
							classifier = _classifier : Classifier,
							owningPackage = _package : Package { 
									packagedElement = _element : Element
							} 
						}
	};
	--check stereotype
	checkonly domain uml _bpmnExtensionAttributeValue : 
								bpmnprofile::ExtensionAttributeValue {
		base_Slot = _slot 
	};
	when {
		PropertyToExtensionAttributeDefinition( _extensionAttributeDefinition, _classifier );
		ElementToBaseElement( _baseElement, _element );
	}
}


--***************************************
--	Processes and Global Tasks
--***************************************


relation BehaviorToCallableElement
--map UML Behavior subtypes to BPMN CallableElement subtypes as appropriate
{
	enforce domain bpmn _callableElement : CallableElement { }
	checkonly domain uml _behavior : Behavior { }
	where {
		ActivityToProcess( _callableElement, _behavior );
		OpaqueBehaviorToGlobalTask( _callableElement, _behavior );
		OpaqueBehaviorToGlobalManualTask( _callableElement, _behavior );
		OpaqueBehaviorToGlobalScriptTask( _callableElement, _behavior );
		OpaqueBehaviorToGlobalUserTask( _callableElement, _behavior );
		OpaqueBehaviorToGlobalBusinessRuleTask( _callableElement, _behavior );
	}
}


relation ActivityToProcess
--map UML Activity to BPMN Process
{ 
	enforce domain bpmn _process : Process{ 
		name = _name : String{},
		processType = _processType : ProcessType{ },
		isClosed = _isClosed : Boolean,
		isExecutable = _isExecutable : Boolean,
		supports = _supports : Process,
		properties = _property : Property 
	};
	checkonly domain uml _activity : uml::Activity{ 
		name = _name,
		generalization = _generalization : uml::Generalization {
										_general : uml::Classifier },
		ownedAttribute = _umlProperty : uml::Property,
		classifierBehavior = _activity 
	};
	--check stereotype
	checkonly domain uml _umlProcess : bpmnprofile::Process {
		base_Activity  =  _activity,
		processType  =  _processType,
		isClosed = _isClosed,
		isExecutable = _isExecutable 
	};
	where { 
		ActivityToProcess( _supports, _general );
		PropertyToProperty( _property, _umlProperty ); 
	}
}



relation PropertyToProperty
--map UML Property to BPMN Property
{ 
	enforce domain bpmn _property : Property { 
		name = _name : String{},
		itemSubjectRef = _itemSubjectRef : ItemDefinition 
	};
	checkonly domain uml _property : uml::Property { 
		name = _name ,
		type = _class : uml::Class 
	};
	--check stereotype
	checkonly domain uml _umlProperty : bpmnprofile::BPMNProperty {
		base_Property  =  _property 
	};
	when { 
		ClassToItemDefinition( _itemSubjectRef, _class );
	}
}


relation OpaqueBehaviorToGlobalTask
--map OpaqueBehavior to GlobalTask
{ 
	enforce domain bpmn _globalTask : GlobalTask {
		name  =  _name : String 
	};
	checkonly domain uml _opaqueBehavior : uml::OpaqueBehavior {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlGlobalTask : bpmnprofile::GlobalTask {
		base_OpaqueBehavior = _opaqueBehavior 
	};
}


relation OpaqueBehaviorToGlobalManualTask
--map OpaqueBehavior to GlobalManualTask
{
	enforce domain bpmn _globalManualTask : GlobalManualTask {
		name  =  _name : String 
	};
	checkonly domain uml _opaqueBehavior : uml::OpaqueBehavior {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlGlobalManualTask : bpmnprofile::GlobalManualTask {
		base_OpaqueBehavior = _opaqueBehavior 
	};
}


relation OpaqueBehaviorToGlobalScriptTask
--map OpaqueBehavior with GlobalScriptTask stereotype applied to GlobalScriptTask
{ 
	enforce domain bpmn _globalScriptTask : GlobalScriptTask {
		name  =  _name : String{},
		scriptFormat  =  _scriptFormat : String{},
		script = _script : String 
	};
	checkonly domain uml _opaqueBehavior : uml::OpaqueBehavior {
		name = _name,
		language = _scriptFormat,
		body = _script 
	};
	--check stereotype
	checkonly domain uml ugst : bpmnprofile::GlobalScriptTask {
		base_OpaqueBehavior = _opaqueBehavior 
	};
}


relation OpaqueBehaviorToGlobalUserTask
--map OpaqueBehavior with GlobalUserTask applied to GlobalUserTask
{ 
	enforce domain bpmn _globalUserTask : GlobalUserTask {
		name  =  _name : String{},
		implementation  =  _implementation : String{},
		renderings = _rendering : Image
	};
	checkonly domain uml _opaquebehavior : uml::OpaqueBehavior {
		name = _name,
		body = _implementation 
	};
	--check stereotype
	checkonly domain uml _umlGlobalUserTask : bpmnprofile::GlobalUserTask {
		base_OpaqueBehavior = _opaqueBehavior,
		icon = _image 
	};
	where {
		ImageToRendering( _rendering, _image );
	}
}


relation OpaqueBehaviorToGlobalBusinessRuleTask
--map UML OpaqueBehavior with GlobalbusinessRuleTask stereotype to BPMN GlobalBusinessRuleTask
{ 
	enforce domain bpmn _globalBusinessRuleTask : GlobalBusinessRuleTask {
		name = _name : String{},
		implementation = _implementation : String 
	};
	checkonly domain uml _opaqueBehavior : uml::OpaqueBehavior  {
		name = _name,
		body = _implementation 
	};
	--check stereotype
	checkonly domain uml _umlGlobalBusinessRuleTask : bpmnprofile::GlobalBusinessRuleTask {
		base_OpaqueBehavior = _opaqueBehavior 
	};
}


relation ImageToRendering
--map UML Image to BPMN Rendering
{
	_name : String;
	enforce domain bpmn _rendering : Rendering {
		name = _name 
	};
	checkonly domain uml _image : uml::Image {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlRendering: bpmnprofile::Rendering {
		base_Image = _image 
	};
}


--***************************************
--	Activities
--***************************************


relation ActionToActivity
--map UML Action to BPMN Activity
{ 
	enforce domain bpmn _activity : Activity { 
		properties = _property : Property,
		default = _default : SequenceFlow 
	};
  	checkonly domain uml _action : uml::Action {
  		ownedAttribute = _umlProperty: uml::Property,
  		outgoing = _umlDefault: uml::ControlFlow { guard = "else" } 
  	};
  	where 
  	{ 	--map types of BPMN Actvity
  		OpaqueActionToTask( _activity, _action );
  		CallBehaviorActionToCallActivity( _activity, _action );
  		OpaqueActionToManualTask( _activity, _action );
  		OpaqueActionToScriptTask( _activity, _action );
       	OpaqueActionToUserTask( _activity, _action );
  		OpaqueActionToBusinessRuleTask( _activity, _action );
  		--other relations that must hold
  		PropertyToProperty( _property, _umlProperty );
  		ControlFlowToSequenceFlow( _default, _umlDefault );
  	}
}


relation StructuredActivityNodeToSubProcess
--map UML StructuredActivityNode to BPMN SubProcess
{
	_name : String;
	_triggeredByEvent : Boolean;
	enforce domain bpmn _subProcess : SubProcess { 
		name = _name,
		triggeredByEvent = _triggeredByEvent 
	};
	checkonly domain uml _structuredActivityNode : uml::StructuredActivityNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlSubProcess : bpmnprofile::SubProcess {
		base_StructuredActivityNode = _structuredActivityNode,
		triggeredByEvent = _triggeredByEvent 
	};	
}


relation StructuredActivityNodeToAdHocSubProcess
--map UML StructuredActivityNode to BPMN AdHocSubProcess 
{
	_name : String;
	_completionCondition : BPMNExpression;
	_ordering : AdHocOrdering;
	_cancelRemainingInstances : Boolean;
	enforce domain bpmn _adHocSubProcess : AdHocSubProcess { 
		name = _name,
		completionCondition = _ completionCondition,
		ordering = _ ordering, 
		cancelRemainingInstances = _ cancelRemainingInstances 
	};
	checkonly domain uml _structuredActivityNode : uml::StructuredActivityNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlAdHocSubProcess : bpmnprofile::AdHocSubProcess {
		base_StructuredActivityNode = _structuredActivityNode, 
		completionCondition = _ completionCondition,
		ordering = _ ordering, 
		cancelRemainingInstances = _ cancelRemainingInstances 
	};

}


relation StructuredActivityNodeToTransaction
--map UML StructuredActivityNode to BPMN Transaction
{
	_name : String;
	_method : String;
	enforce domain bpmn _transaction : Transaction{ 
		name = _name,
		method = _method 
	};
	checkonly domain uml _structuredActivityNode : uml::StructuredActivityNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlTransaction : bpmnprofile:: Transaction {
		base_StructuredActivityNode = _structuredActivityNode, 
		method = _method 
	};
}


relation CallBehaviorActionToCallActivity
--map UML CallBehaviorAction to BPMN CallActivity
{ 
	enforce domain bpmn _callActivity : CallActivity { 
		name = _name : String{},
		calledElement = _calledElement : CallableElement 
	};
	checkonly domain uml _callBehaviorAction : uml::CallBehaviorAction {
		name = _name,
		behavior = _behavior : Behavior{ }
	};
	--check stereotype
	checkonly domain uml _umlCallActivity : bpmnprofile::CallActivity {
		base_CallBehaviorAction = _callBehaviorAction 
	};
	where {
		BehaviorToCallableElement( _calledElement, _behavior );
	}
}
       
relation OpaqueActionToTask
--map UML OpaqueAction to BPMN Task
{
	enforce domain bpmn _task :  Task{ 
		name = _name : String 
	};
	checkonly domain uml _opaqueAction : uml::OpaqueAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmntask : bpmnprofile::Task {
		base_OpaqueAction  =  _opaqueAction 
	};
}


relation CallOperationActionToSendTask
--map UML CallOperationAction to BPMN SendTask
{
	enforce domain bpmn _sendTask :  SendTask{ 
		name = _name : String 
	};
	checkonly domain uml _callOperationAction : uml::CallOperationAction {
		name = _name 
	};
	--check stereotype
		checkonly domain uml _bpmnSendTask : bpmnprofile::SendTask {
		base_CallOperationAction  =  _callOperationAction 
	};
}


relation CallOperationActionToServiceTask
--map UML CallOperationActionto BPMN ServiceTask 
{ 
	enforce domain bpmn _serviceTask :  ServiceTask{ 
		name = _name : String 
	};
	checkonly domain uml _callOperationAction : uml::CallOperationAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmnServiceTask : bpmnprofile::ServiceTask {
		base_CallOperationAction  =  _callOperationAction 
	};
}


relation AcceptEventActionToReceiveTask
--map UML CallOperationAction to BPMN ReceiveTask 
{ 
	enforce domain bpmn _receiveTask :  ReceiveTask{ 
		name = _name : String 
	};
	checkonly domain uml _acceptEventAction : uml::AcceptEventAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmnReceiveTask : bpmnprofile:: ReceiveTask {
		base_ AcceptEventAction  =  _ acceptEventAction 
	};
}


relation OpaqueActionToManualTask
--map UML OpaqueAction to BPMN ManualTask 
{ 
	enforce domain bpmn _manualTask :  ManualTask{ 
		name = _name : String 
	};
	checkonly domain uml _opaqueAction : uml::OpaqueAction {
		name = _name 
	};
	--check stereotype 
	checkonly domain uml _umlManualTask : bpmnprofile:: ManualTask {
		base_OpaqueAction  =  _opaqueAction 
	};
}


relation OpaqueActionToScriptTask
--map UML OpaqueAction to BPMN ScriptTask 
{ 
	enforce domain bpmn _scriptTask :  ScriptTask{ 
		name = _name : String{},
		scriptFormat = _scriptFormat : String{},
		script = _script : String 
	};
	checkonly domain uml _opaqueAction : uml::OpaqueAction {
		name = _name,
		language = _scriptFormat,
		body = _script 
	};
	--check stereotype 
	checkonly domain uml _umlScriptTask : bpmnprofile::ScriptTask {
		base_OpaqueAction  =  _opaqueAction 
	};
}


relation OpaqueActionToUserTask
--map UML OpaqueAction to BPMN UserTask 
{ 
	enforce domain bpmn _userTask :  UserTask{ 
		name = _name : String{},
		implementation = _implementation : String{},
		renderings = _rendering : Image 
	};
	checkonly domain uml _opaqueAction : uml::OpaqueAction {
		name = _name,
		body = _implementation 
	};
	--check stereotype
	checkonly domain uml _umlUserTask : bpmnprofile::UserTask {
		base_OpaqueAction  =  _opaqueAction,
		icon = _image 
	};
	where {
		ImageToRendering( _rendering, _image );
	}
}


relation OpaqueActionToBusinessRuleTask
--map UML OpaqueAction to BPMN BusinessRuleTask 
{ 
	enforce domain bpmn _businessRuleTask :  BusinessRuleTask { 
		name = _name : String{},
		implementation = _implementation : String 
	};
	checkonly domain uml _opaqueAction : uml::OpaqueAction {
		name = _name,
		body = _implementation 
	};
	--check stereotype
	checkonly domain uml _umlBusinessRuleTask : bpmnprofile:: BusinessRuleTask{
		base_OpaqueAction  =  _opaqueAction 
	};
}


--***************************************
--	Sequence Flows
--***************************************


relation ControlFlowToSequenceFlow
--map UMLControlFlow with SequenceFlow stereotype to BPMN SequenceFlow 
{ 
	enforce domain bpmn _sequenceFlow : SequenceFlow {
		conditionExpression = _conditionExpression : BPMNExpression,
		sourceRef = _sourceRef : FlowNode,
		targetRef = _targetRef : FlowNode 
	};
	checkonly domain uml _controlFlow : uml::ControlFlow {
		guard = _umlConditionExpression,
		source = _umlSourceRef,
		target = _umlTargetRef 
	};
	--check stereotype
	checkonly domain uml usf : bpmnprofile::SequenceFlow {
		base_ControlFlow = umlCF 
	};
	when 
	{ 
		OpaqueExpressionToExpression( _conditionExpression, _umlConditionExpression );
		ActivityNodeToFlowNode( _sourceRef, _umlSourceRef );
		ActivityNodeToFlowNode( _targetRef, _umlTargetRef );
	}
}


relation ActivityNodeToFlowNode
--map appropriate UML ActivityNodes to BPMNFlow Nodes
{ 
	enforce domain bpmn _flowNode : FlowNode { };
	checkonly domain uml _activityNode : uml::ActivityNode { };
	where {
		--map Events
		StartEventToInitialNode( _flowNode, _activityNode);
		IntermediateCatchEventToAcceptEventAction( _flowNode, _activityNode );
		BoundaryEventToAcceptEventAction( _flowNode, _activityNode );
	}
}


--*********************
--	Events
--*********************


relation CallOperationActionToIntermediateThrowEvent
--map UML CallOperationAction to BPMN IntermediateThrowEvent 
{ 
	enforce domain bpmn _intermediateThrowEvent : IntermediateThrowEvent {
		name = _name : String{},
		eventDefinitions = _eventDefinition : EventDefinition 
	};
	checkonly domain uml _callOperationAction : uml::CallOperationAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlIntermediateThrowEvent : bpmnprofile::IntermediateThrowEvent {
		base_CallOperationAction = _callOperationAction,
		eventDifinitions = _umlEventDefinition 
	};
	where {
		EventToEventDefinition( _eventDefinition, _umlEventDefinition );
	}
}


relation CallOperationActionToImplicitThrowEvent
--map UML CallOperationAction to BPMN ImplicitThrowEvent 
{ 
	enforce domain bpmn _implicitThrowEvent : ImplicitThrowEvent {
		name = _name : String{},
		eventDefinitions = _eventDefinition : EventDefinition 
	};
	checkonly domain uml _callOperationAction : uml::CallOperationAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlImplicitThrowEvent : bpmnprofile::ImplicitThrowEvent {
		base_CallOperationAction = _callOperationAction,
		eventDifinitions = _umlEventDefinition 
	};
	where {
		EventToEventDefinition( _eventDefinition, _umlEventDefinition );
	}
}


relation FlowFinalNodeToEndEvent
--map UML FlowFinalNode to BPMN EndEvent
{ 
	enforce domain bpmn _endEvent : EndEvent {
		name = _name : String
	};
	checkonly domain uml _flowFinalNode : uml::FlowFinalNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlEndEvent : bpmnprofile::EndEvent {
		base_FlowFinalNode = _flowFinalNode 
	};
}


relation CallOperationActionToEndEvent
--map UML CallOperationAction with EndEvent stereotype to BPMN EndEvent
{ 
	enforce domain bpmn _endEvent : EndEvent {
		name = _name : String
	};
	checkonly domain uml _callOperationAction : uml::CallOperationAction {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlEndEvent : bpmnprofile::EndEvent {
		base_CallOperationAction = _callOperationAction 
	};
}


relation InitialNode ToStartEvent
--map UML InitialNode to BPMN StartEvent
{
	enforce domain bpmn _startEvent : StartEvent {
		name = _name : String{},
		isInterrupting = _isInterrupting : Boolean
	};
	checkonly domain uml _initialNode : uml::InitialNode { 
		name = _name 
	};
	--check stereotype 
	checkonly domain uml _umlStartEvent : bpmnprofile::StartEvent {
		base_InitialNode = _initialnode,
		isInterrupting = _isInturrepting 
	};
}


relation AcceptEventAction ToStartEvent
--map UML AcceptEventAction to BPMN StartEvent 
{
	enforce domain bpmn _startEvent : StartEvent {
		name = _name : String{},
		isInterrupting = _isInterrupting : Boolean
	};
	checkonly domain uml _acceptEventAction : uml::AcceptEventAction {
		name = _name,
		isUnmarshall = false 
	};
	--check stereotype 
	checkonly domain uml _umlStartEvent : bpmnprofile::StartEvent {
		base_InitialNode = _initialnode,
		isInterrupting = _isInturrepting 
	};
}


relation AcceptEventActionToIntermediateCatchEvent
--map UML AcceptEventAction to BPMN IntermediateCatchEvent 
{ 
	enforce domain bpmn _intermediateCatchEvent : IntermediateCatchEvent {
		name = _name : String{},
		eventDefinitions = _eventDefinition : EventDefinition,
	};
	checkonly domain uml _acceptEventAction : uml::AcceptEventAction {
		name = _name,
		trigger = _trigger : Trigger { event = _umlEventDefinition},
		isUnmarshall = false 
	};
	--check stereotype and copy attributes
	checkonly domain uml _umlIntermediateCatchEvent : bpmnprofile::IntermediateCatchEvent {
		base_AcceptEventAction = _acceptEventAction,
		parallelMultiple = _parallelMultiple 
	};
	where {
		EventToEventDefinition( _eventDefinition, _umlEventDefinition );
	}
}


relation AcceptEventActionToBoundaryEvent
--map UML AcceptEventAction to BPMN BoundaryEvent 
{ 
	enforce domain bpmn _boundaryEvent : BoundaryEvent {
		name = _name : String{},
		cancelActivity = _cancelActivity : Boolean,
		eventDefinitions = _eventDefinition : EventDefinition,
	};
	checkonly domain uml _acceptEventAction : uml::AcceptEventAction {
		name = _name,
		trigger = _trigger : Trigger { event = _eventDefinition},
		isUnmarshall = false 
	};
	--check stereotype and copy attributes
	checkonly domain uml _umlBoundaryEvent : bpmnprofile::BoundaryEvent {
		base_AcceptEventAction = _acceptEventAction,
		cancelActivity = _cancelActivity,
		parallelMultiple = _parallelMultiple 
	};
	where {
		EventToEventDefinition( _eventDefinition, _umlEventDefinition );
	}
}


--Map Event Definitions
relation EventToEventDefinition
{
	enforce domain bpmn _eventDefinition : EventDefinition;
	checkonly domain uml _event : Event;
	where {
		CallEventToErrorEventDefinition( _eventDefinition, _event ); 
		CallEventToEscalationEventDefinition( _eventDefinition, _event ); 
		CallEventToMessageEventDefinition( _eventDefinition, _event ); 
		CallEventToSignalEventDefinition( _eventDefinition, _event );
	}
}


relation CallEventToErrorEventDefinition
--map UML CallEvent to BPMN ErrorEventDefinition 
{
	enforce domain bpmn _errorEventDefinition : ErrorEventDefinition {
		name = _name : String{},
		errorRef = _error : Error 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlErrorEventDefinition : bpmnprofile::ErrorEventDefinition {
		base_CallEvent = _callEvent,
		errorRef = _umlError 
	};
	where {
		ClassToError( _error, _umlError );
	}
}


relation CallEventToEscalationEventDefinition
--map UML CallEvent to BPMN EscalationEventDefinition 
{
	enforce domain bpmn _escalationEventDefinition : EscalationEventDefinition {
		name = _name : String{},
		escalationRef = _escalation : Escalation 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlEscalationEventDefinition : bpmnprofile::EscalationEventDefinition {
		base_CallEvent = _callEvent,
		escalationRef = _umlEscalation 
	};
	where {
		ClassToEscalation( _escalation, _umlEscalation );
	}
}


relation CallEventToEscalationEventDefinition
--map UML CallEvent to BPMN MessageEventDefinition 
{
	enforce domain bpmn _messageEventDefinition : MessageEventDefinition {
		name = _name : String{},
		messageRef = _message : Message,
		operationRef = _operation : Operation 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlMessageEventDefinition : bpmnprofile::MessageEventDefinition {
		base_CallEvent = _callEvent,
		messageRef = _umlMessage,
		operationRef = _umlOperation 
	};
	where {
		ClassToMessage( _message, _umlMessage );
		ClassToOperation( _operation, _umlOperation );
	}
}


relation CallEventToSignalEventDefinition
--map UML CallEvent to BPMN SignalEventDefinition 
{
	enforce domain bpmn _signalEventDefinition : SignalEventDefinition {
		name = _name : String{},
		signalRef = _segnal : Signal 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlSignalEventDefinition : bpmnprofile::SignalEventDefinition {
		base_CallEvent = _callEvent,
		signalRef = _umlSignal 
	};
	where {
		ClassToSignal( _signal, _umlSignal );
	}
}


relation ClassToError
--map UML Class to BPMN Error 
{
	enforce domain bpmn _error : Error {
		name = _name : String{},
		errorCode = _errorCode : String 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlError : bpmnprofile::Error {
		base_Class = _class,
		errorCode = _errorCode 
	};
}


relation ClassToEscalation
--map UML Class to BPMN Escalation 
{
	enforce domain bpmn _escalation : Escalation {
		name = _name : String{},
		escalationCode = _escalationCode : String 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlEscalation : bpmnprofile::Escalation {
		base_Class = _class,
		escalationCode = _escalationCode 
	};
}


relation ClassToMessage
--map UML Class to BPMN Message  
{
	enforce domain bpmn _message : Message {
		name = _name : String 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlMessage : bpmnprofile::BPMNMessage {
		base_Class = _class 
	};
}


relation ClassToSignal
--map UML Class to BPMN Signal 
{
	enforce domain bpmn _signal :  Signal{
		name = _name : String 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlSignal : bpmnprofile::BPMNSignal {
		base_Class = _class 
	};
}


relation CallEventToTerminateEventDefinition
--map UML CallEvent to BPMN TerminateEventDefinition 
{
	enforce domain bpmn _terminateEventDefinition : TerminateEventDefinition{
		name = _name : String 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlTerminateEventDefinition : bpmnprofile::TerminateEventDefinition {
		base_CallEvent = _callEvent 
	};
}


relation CallEventToCancelEventDefinition
--map UML CallEvent to BPMN CancelEventDefinition 
{
	enforce domain bpmn _cancelEventDefinition : CancelEventDefinition{
		name = _name : String 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCancelEventDefinition : bpmnprofile::CancelEventDefinition {
		base_CallEvent = _callEvent 
	};
}


relation CallEventToCompensateEventDefinition
--map UML CallEvent to BPMN CompensateEventDefinition
{
	enforce domain bpmn _compensateEventDefinition : CompensateEventDefinition{
		name = _name : String{},
		waitForCompletion = _waitForCompletion : Boolean,
		activityRef = _activity : Activity 
	};
	checkonly domain uml _callEvent : uml::CallEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCompensateEventDefinition : bpmnprofile::CompensateEventDefinition {
		base_CallEvent = _callEvent,
		waitForCompletion = _waitForCompletion,
		activityRef = _umlActivity 
	};
	where {
		ActionToActivity( _activity, _umlActivity );
	}
}


relation ChangeEventToConditionalEventDefinition
--map UML ChangeEvent to BPMN ConditionalEventDefinition 
{
	enforce domain bpmn _conditionalEventDefinition : ConditionalEventDefinition{
		name = _name : String 
	};
	checkonly domain uml _changeEvent : uml::ChangeEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlConditionalEventDefinition : bpmnprofile::ConditionalEventDefinition {
		base_ChangeEvent = _changeEvent 
	};
}


relation ChangeEventToTimerEventDefinition
--map UML ChangeEvent to BPMN TimerEventDefinition 
{
	enforce domain bpmn _timerEventDefinition : TimerEventDefinition{
		name = _name : String{},
		timeCycle = _timeCycleExpression : Expression,
		timeDate = _timeDateExpression : Expression,
		timeDuration = _timeDurationExpression : Expression 
	};
	checkonly domain uml _changeEvent : uml::ChangeEvent { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlTimerEventDefinition : bpmnprofile::TimerEventDefinition {
		base_ChangeEvent = _changeEvent,
		timeCycle = _umltimeCycleExpression,
		timeDate = _umltimeDateExpression,
		timeDuration = _umltimeDurationExpression 
	};
	where {
		OpaqueExpressionToExpression(_timeCycleExpression, _umltimeCycleExpression ); 
		OpaqueExpressionToExpression(_timeDateExpression, _umltimeDateExpression ); 
		OpaqueExpressionToExpression(_timeDurationExpression, _umltimeDurationExpression );
	}
}


--*******************************
--	Gateways
--*******************************

relation MergeNodeToExclusiveGateway
--map UML MergeNode to BPMN ExclusiveGateway 
{
	enforce domain bpmn _exclusiveGateway : ExclusiveGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _mergeNode : uml:: MergeNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlExclusiveGateway : bpmnprofile::ExclusiveGateway {
		base_MergeNode = _mergeNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
	}
}

relation DecisionNodeToExclusiveGateway
--map UML DecisionNode to BPMN ExclusiveGateway 
{
	enforce domain bpmn _exclusiveGateway : ExclusiveGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _decisionNode : uml::DecisionNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlExclusiveGateway : bpmnprofile::ExclusiveGateway {
		base_DecisionNode = _decisionNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
	}
}


relation JoinNodeToParallelGateway
--map UML JoinNode to BPMN ParallelGateway 
{
	enforce domain bpmn _parallelGateway : ParallelGateway {
		name = _name : String
	};
	checkonly domain uml _joinNode : uml::JoinNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlParallelGateway : bpmnprofile::ParallelGateway {
		base_JoinNode = _joinNode 
	};
}


relation ForkNodeToParallelGateway
--map UML ForkNode to BPMN ParallelGateway 
{
	enforce domain bpmn _parallelGateway : ParallelGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _forkNode : uml::ForkNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlParallelGateway : bpmnprofile::ParallelGateway {
		base_ForkNode = _forkNode 
	};
}


relation ForkNodeToEventBasedGateway
--map UML ForkNode to BPMN EventBasedGateway
{
	enforce domain bpmn _eventBasedGateway : EventBasedGateway {
		name = _name : String{},
		instantiate = _instantiate : Boolean,
		eventGatewayType = _eventGatewayType : EventGatewayType 
	};
	checkonly domain uml _forkNode : uml::ForkNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlEventBasedGateway : bpmnprofile:: EventBasedGateway {
		base_ForkNode = _forkNode,
		instantiate = _instantiate,
		eventGatewayType = _eventGatewayType 
	};
}


relation JoinNodeToComplexGateway
--map UML JoinNode to BPMN ComplexGateway 
{
	enforce domain bpmn _complexGateway : ComplexGateway {
		name = _name : String{},
		default = _default : SequenceFlow,
		activationCondition = _activationCondition : Expression 
	};
	checkonly domain uml _joinNode : uml::JoinNode {
		name = _name,
		joinSpec = _joinSpec : BPMNExpression 
	};
	--check stereotype
	checkonly domain uml _umlComplexGateway : bpmnprofile::ComplexGateway {
		base_JoinNode = _joinNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
		OpaqueExpressionToExpression( _activationCondition, _joinSpec );
	}
}


relation ForkNodeToComplexGateway
--map UML ForkNode to BPMN ComplexGateway 
{
	enforce domain bpmn _complexGateway : ComplexGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _forkNode : uml::ForkNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlComplexGateway : bpmnprofile::ComplexGateway {
		base_ForkNode = _forkNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
	}
}


relation JoinNodeToInclusiveGateway
--map UML JoinNode to BPMN ComplexGateway 
{
	enforce domain bpmn _inclusiveGateway : InclusiveGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _joinNode : uml::JoinNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlInclusiveGateway : bpmnprofile::InclusiveGateway {
		base_JoinNode = _joinNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
	}
}


relation ForkNodeToInclusiveGateway
--map UML ForkNode to BPMN ComplexGateway 
{
	enforce domain bpmn _inclusiveGateway : InclusiveGateway {
		name = _name : String{},
		default = _default : SequenceFlow 
	};
	checkonly domain uml _forkNode : uml::ForkNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlInclusiveGateway : bpmnprofile::InclusiveGateway {
		base_ForkNode = _forkNode,
		default = _umldefault 
	};
	where {
		ControlFlowToSequenceFlow( _default, _umldefault);
	}
}


--*******************************
--	Data
--*******************************

--InputOutputSpecification #1: for CallActivity
relation CallBehaviorActionToInputOutputSpecification
--map CallBehaviorAction to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(CallActivity.ioSpecification) = _callActivity : CallActivity 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Action = _callBehaviorAction 
	};
	when {
		CallBehaviorActionToCallActivity( _callActivity, _callBehaviorAction );
	}
}


--InputOutputSpecification #2: for Process
relation ActivityToInputOutputSpecification
--map Activity to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(Process.ioSpecification) = _process : Process 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Behavior = _activity 
	};
	when {
		ActivityToProcess( _process, _activity );
	}
}


--InputOutputSpecification #3: for GlobalTask
relation OpaqueActionToInputOutputSpecification
--map OpaqueBehavior to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(GlobalTask.ioSpecification) = _globalTask : GlobalTask 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Behavior = _opaqueBehavior 
	};
	when {
		OpaqueBehaviorToGlobalTask( _globalTask, _opaqueBehavior );
	}
}


--InputOutputSpecification #4: for Task
relation OpaqueActionToInputOutputSpecification
--map OpaqueAction to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(Task.ioSpecification) = _task : Task 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Action = _opaqueAction 
	};
	when {
		OpaqueActionToTask( _task, _ opaqueAction );
	}
}


--InputOutputSpecification #5: for SendTask
relation CallOperationActionToInputOutputSpecification
--map CallOperationAction to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(SendTask.ioSpecification) = _sendTask : SendTask 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Action = _callOperationAction 
	};
	when {
		CallOperationActionToSendTask( _sendTask, _ callOperationAction );
	}
}


--InputOutputSpecification #6: for ServiceTask
relation CallOperationActionToInputOutputSpecification
--map CallOperationAction to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(ServiceTask.ioSpecification) = _serviceTask : ServiceTask 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Action = _callOperationAction 
	};
	when {
		CallOperationActionToServiceTask( _serviceTask, _ callOperationAction );
	}
}


--InputOutputSpecification #7: for ReceiveTask
relation AcceptEventActionToInputOutputSpecification
--map CallOperationAction to corresponding BPMN InputOutputSpecification 
{
	enforce domain bpmn _inputOutputSpecification : InputOutputSpecification {
		opposite(ReceiveTask.ioSpecification) = _receiveTask : ReceiveTask 
	};
	--check stereotype
	checkonly domain uml _umlInputOutputSpecificatoin : bpmnprofile::InputOutputSpecification {
		base_Action = _acceptEventAction 
	};
	when {
		CallOperationActionToServiceTask ( _receiveTask, _ acceptEventAction );
	}
}


relation ParameterSetToInputSet
--map UML ParameterSet to BPMN InputSet 
{
	enforce domain bpmn _inputSet : InputSet {
		name = _name : String{},
		opposite( InputOutputSpecification.inputSets ) = _ioSpec : 
															InputOutputSpecification { 
																opposite( CallableElement.ioSpecification ) =
																	_callableElement : CallableElement } 
	};
	checkonly domain uml _parameterSet : uml::ParameterSet {
		name = _name,
		opposite( Behavior.ownedParameterSet ) = _behavior : Behavior 
	};
	--check stereotype
	checkonly domain uml _umlInputSet : bpmnProfile::InputSet {
		base_ParameterSet = _parameterSet 
	};
	where {
		BehaviorToCallableElement( _callableElement, _behavior );
	}
}


relation ParameterSetToOutputSet
--map UML ParameterSet to BPMN OutputSet 
{
	enforce domain bpmn _outputSet : OutputSet {
		name = _name : String{},
		opposite( InputOutputSpecification.outputSets ) = _ioSpec : 
															InputOutputSpecification { 
																opposite( CallableElement.ioSpecification ) =
																	_callableElement : CallableElement } 
	};
	checkonly domain uml _parameterSet : uml::ParameterSet {
		name = _name,
		opposite( Behavior.ownedParameterSet ) = _behavior : Behavior 
	};
	--check stereotype
	checkonly domain uml _umlOutputSet : bpmnprofile::OutputSet {
		base_ParameterSet = _parameterSet 
	};
	where {
		BehaviorToCallableElement( _callableElement, _behavior );
	}
}


relation ActivityParameterNodeToInputPin
--map UML ActivityParameterNode to BPMN InputPin
{
	enforce domain bpmn _inputPin : InputPin {
		name = _name : String{},
		opposite( InputOutputSpecification.dataInputs ) = _ioSpec : InputOutputSpecification { 
		opposite(CallableElement.ioSpecification) = _callableElement : CallableElement } 
	};
	checkonly domain uml _activityParameterNode : uml::ActivityParameterNode {
		name = _name,
		activity = _activity : uml::Activity 
	};
	--check stereotype
	checkonly domain uml _umlDataInput : bpmnprofile::DataInput {
		base_ActivityParameternode = _activityParameterNode 
	};
	where {
		ActivityToCallableElement( _callableElement, _activity );
	}
}


relation ActivityParameterNodeToOutputPin
--map UML ActivityParameterNode to BPMN OutputPin 
{
	enforce domain bpmn _outputPin : OutputPin {
		name = _name : String{},
		opposite( InputOutputSpecification.dataInputs ) = _ioSpec : InputOutputSpecification { 
		opposite(CallableElement.ioSpecification) = _callableElement : CallableElement } 
	};
	checkonly domain uml _activityParameterNode : uml::ActivityParameterNode {
		name = _name,
		activity = _activity : uml::Activity 
	};
	--check stereotype
	checkonly domain uml _umlDataOutput : bpmnprofile::DataOutput {
		base_ActivityParameternode = _activityParameterNode 
	};
	where {
		ActivityToCallableElement( _callableElement, _activity );
	}
}


relation InputPinToDataInput
--map UML InputPin to BPMN DataInput 
{
	enforce domain bpmn _dataInput : DataInput {
		name = _name : String{},
		opposite( InputOutputSpecification.dataInputs ) = _ioSpec : InputOutputSpecification { 
										opposite(Activity.ioSpecification) = _activity : Activity } 
	};
	checkonly domain uml _inputPin : uml::InputPin {
		name = _name,
		action = _action : uml::Action 
	};
	--check stereotype
	checkonly domain uml _umlDataInput : bpmnprofile::DataInput {
		base_InputPin = _inputPin 
	};
	where {
		ActionToActivity( _activity, _action );
	}
}


relation OutputPinToDataOutput
--map UML OutputPin to BPMN DataOutput 
{
	enforce domain bpmn _dataOutput : DataOutput {
		name = _name : String{},
		opposite( InputOutputSpecification.dataOutputs ) = _ioSpec : InputOutputSpecification { 
											opposite(Activity.ioSpecification) = _activity : Activity } 
	};
	checkonly domain uml _outputPin : uml::OutputPin {
		name = _name,
		action = _action : uml::Action 
	};
	--check stereotype
	checkonly domain uml _umlDataOutput : bpmnprofile::DataOutput {
		base_OutputPin = _outputPin 
	};
	where {
		ActionToActivity( _activity, _action );
	}
}


relation DataStoreNodeToDataObject
--map UML DataStoreNode to BPMN DataObject 
{
	enforce domain bpmn _dataObject : DataObject {
		name = _name : String 
	};
	checkonly domain uml _dataStoreNode : uml::DataStoreNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlDataObject : bpmnprofile::DataObject {
		base_DataStoreNode = _dataStoreNode 
	};
}


relation DataStoreNodeToDataObjectRef
--map UML DataStoreNode to BPMN DataObjectRef 
{
	enforce domain bpmn _dataObjectRef : DataObjectRef {
		dataObjectRef = _dataObject : DataObject { name = _name : String } 
	};
	checkonly domain uml _dataStoreNode : uml::DataStoreNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlDataObjectRef : bpmnprofile::DataObjectRef {
		base_DataStoreNode = _dataStoreNode 
	};
}


--*******************************
--	LoopCharacteristics
--*******************************

relation LoopNodeToStandardLoopCharacteristics
--map UML LoopNode to BPMN StandardLoopCharactistics 
{
	enforce domain bpmn _standardLoopCharacteristics : StandardLoopCharacteristics {
		name = _name : String{},
		loopMaximum = _loopMaximum : Integer 
	};
	checkonly domain uml _loopNode : uml::LoopNode {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlStandardLoopCharacteristics : bpmnprofile::StandardLoopCharacteristics {
		base_LoopNode = _loopNode,
		loopMaximum = _loopMaximum 
	};
}


relation ExpansionRegionToMultiInstanceLoopCharacteristics
--map UML ExpansionRegion to BPMN MultiInstanceLoopCharacteristics 
{
	enforce domain bpmn _multiInstanceLoopCharacteristics : MultiInstanceLoopCharacteristics {
		name = _name : String{},
		behavior = _behavior : MultiInstanceBehavior,
		completionCondition = _completionCondition : Expression 
	};
	checkonly domain uml _expansionRegion : uml::ExpansionRegion {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlMultiInstanceLoopCharacteristics :
		bpmnprofile::MultiInstanceLoopCharacteristics {
		base_ExpansionRegion = _expansionRegion,
		behavior = _behavior,
		completionCondition = _umlCompletionCondition 
	};
	where {
		OpaqueExpressionToExpression( _completionCondition, _umlCompletionCondition );
	}
}


relation ExpansionRegionToComplexBehaviorDefinition
--map UML ExpansionRegion to BPMN ComplexBehaviorDefinition  
{
	enforce domain bpmn _complexBehaviorDefinition : ComplexBehaviorDefinition {
		name = _name : String 
	};
	checkonly domain uml _expansionRegion : uml::ExpansionRegion {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlComplexBehaviorDefinition : bpmnprofile::ComplexBehaviorDefinition {
		base_ExpansionRegion = _expansionRegion 
	};
}



--*******************************
--	Lanes and Resources
--*******************************


relation ActivityPartitionToLane
--map UML ActivityPartition to BPMN Lane 
{
	enforce domain bpmn _lane : Lane {
		name = _name : String 
	};
	checkonly domain uml _activityPartition : uml::ActivityPartition {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlLane : bpmnprofile::Lane {
		base_ActivityPartition = _activityPartition 
	};
}


relation ActivityPartitionToLaneSet
--map UML ActivityPartition to BPMN LaneSet 
{
	enforce domain bpmn _laneSet : LaneSet {
		name = _name : String{},
		subprocess = _subProcess : SubProcess 
	};
	checkonly domain uml _activityPartition : uml::ActivityPartition {
		name = _name,
		isDimension = true 
	};
	--check stereotype
	checkonly domain uml _umlLaneSet : bpmnprofile::LaneSet {
		base_ActivityPartition = _activityPartition,
		subprocess = _umlSubProcess 
	};
	where {
		StructuredActivityNodeToSubProcess( _subProcess, _umlSubProcess );
	}
}


relation ClassToResource
--map UML Class to BPMN Resource 
{
	enforce domain bpmn _resource : Resource {
		name = _name : String 
	};
	checkonly domain uml _class : uml::Class {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlResource : bpmnprofile::Resource {
		base_Class = _class 
	};
}


relation PropertyToResourceRole
--map UML Property to BPMN ResourceRole 
{
	enforce domain bpmn _resourceRole : ResourceRole {
		name = _name : String{},
		resourceAssignmentExpression = _resourceAssignmentExpression :
											ResourceAssignmentExpression 
	};
	checkonly domain uml _property : uml::Property {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlResourceRole : bpmnprofile::ResourceRole {
		base_Property = _property,
		resourceAssignmentExpression = _umlResourceAssignmentExpression 
	};
	where {
		OpaqueExpressionToResourceAssignmentExpression( _resourceAssignmentExpression,
														_umlResourceAssignmentExpression);
	}
}


relation PropertyToPerformer
--map UML Property to BPMN Performer 
{
	enforce domain bpmn _performer : Performer {
		name = _name : String{},
		resourceAssignmentExpression = _resourceAssignmentExpression :
											ResourceAssignmentExpression 
	};
	checkonly domain uml _property : uml::Property {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlPerformer : bpmnprofile::Performer {
		base_Property = _property,
		resourceAssignmentExpression = _umlResourceAssignmentExpression 
	};
	where {
		OpaqueExpressionToResourceAssignmentExpression( _resourceAssignmentExpression,
														_umlResourceAssignmentExpression);
	}
}


relation PropertyToHumanPerformer
--map UML Property to BPMN HumanPerformer 
{
	enforce domain bpmn _humanPerformer : HumanPerformer {
		name = _name : String{},
		resourceAssignmentExpression = _resourceAssignmentExpression :
											ResourceAssignmentExpression 
	};
	checkonly domain uml _property : uml::Property {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlHumanPerformer : bpmnprofile::HumanPerformer {
		base_Property = _property,
		resourceAssignmentExpression = _umlResourceAssignmentExpression 
	};
	where {
		OpaqueExpressionToResourceAssignmentExpression( _resourceAssignmentExpression,
														_umlResourceAssignmentExpression);
	}
}


relation PropertyToPotentialOwner
--map UML Property to BPMN PotentialOwner 
{
	enforce domain bpmn _potentialOwner : PotentialOwner {
		name = _name : String{},
		resourceAssignmentExpression = _resourceAssignmentExpression :
											ResourceAssignmentExpression 
	};
	checkonly domain uml _property : uml::Property {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlPotentialOwner : bpmnprofile::PotentialOwner {
		base_Property = _property,
		resourceAssignmentExpression = _umlResourceAssignmentExpression 
	};
	where {
		OpaqueExpressionToResourceAssignmentExpression( _resourceAssignmentExpression,
														_umlResourceAssignmentExpression);
	}
}


relation PropertyToResourceParameter
--map UML Property to BPMN ResourceParameter 
{
	enforce domain bpmn _resourceParameter : ResourceParameter {
		name = _name : String 
	};
	checkonly domain uml _property : uml::Property {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlResourceParameter : bpmnprofile::ResourceParameter {
		base_Property = _property 
	};
}


relation SlotToResourceParameterBinding
--map UML Slot to BPMN ResourceParameterBinding 
{
	enforce domain bpmn _resourceParameterBinding : ResourceParameterBinding {
		name = _name : String 
	};
	checkonly domain uml _slot : uml:: Slot {
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlResourceParameterBinding : bpmnprofile::ResourceParameterBinding {
		base_Slot = _slot 
	};
}


--*******************************
--	Collaborations
--*******************************

relation CollaborationToCollaboration
--map UML Collaboratoin to BPMN Collaboration 
{
	enforce domain bpmn _bpmnCollaboration : Collaboration {
		name = _name : String{},
		isClosed = _isClosed : Boolean,
		participants = _participant : Participant 
	};
	checkonly domain uml _umlCollaboratoin : uml::Collaboration {
		name = _name,
		ownedAttribute = _property : uml::Property 
	};
	--check stereotype
	checkonly domain uml _umlbpmnCollaboration : bpmnprofile::BPMNCollaboratoin {
		base_Collaboratoin = _umlCollaboratoin,
		isClosed = _isClosed 
	};
	where {
		PropertyToParticipant( _participant, _property );
	}
}

relation InformationFlowToMessageFlow
--map UML InformationFlow to BPMN MessageFlow 
{
	enforce domain bpmn _messageFlow : MessageFlow {
		name = _name : String{},
		collaboration = _collaboration : Collaboration 
	};
	checkonly domain uml _informationFlow : uml::InformationFlow {
		name = _name 
	};			
	--check stereotype
	checkonly domain uml _umlMessageFlow : bpmnprofile::MessageFlow {
		base_InformationFlow = _informationFlow,
		collaboration = _umlCollaboration 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration );
	}
}

relation InformationFlowToConversation
--map UML InformationFlow to BPMN Conversation 
{
	enforce domain bpmn _conversation : Conversation {
		name = _name : String{},
		collaboration = _collaboration : Collaboration,
		messageFlowRefs = _messageFlow : MessageFlow 
	};
	checkonly domain uml _informationFlow : uml::InformationFlow {
		name = _name 
	};			
	--check stereotype
	checkonly domain uml _umlConversation : bpmnprofile::Conversation {
		base_InformationFlow = _informationFlow,
		collaboration = _umlCollaboration,
		messageFlowRefs = _umlMessageFlow 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration );
		InformationFlowToMessageFlow( _messageFlow, _umlMessageFlow );
	}
}

relation InformationFlowToSubConversation
--map UML InformationFlow to BPMN SubConversation 
{
	enforce domain bpmn _subConversation : SubConversation {
		name = _name : String{},
		collaboration = _collaboration : Collaboration,
		messageFlowRefs = _messageFlow : MessageFlow 
	};
	checkonly domain uml _informationFlow : uml::InformationFlow {
		name = _name 
	};			
	--check stereotype
	checkonly domain uml _umlSubConversation : bpmnprofile::SubConversation {
		base_InformationFlow = _informationFlow,
		collaboration = _umlCollaboration,
		messageFlowRefs = _umlMessageFlow 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration ); 
		InformationFlowToMessageFlow( _messageFlow, _umlMessageFlow );
	}
}


relation CollaborationUseToCallConversation
--map UML CollaborationUse to BPMN CallConversation 
{
	enforce domain bpmn _callConversation : CallConversation {
		name = _name : String{},
		collaboration = _collaboration : Collaboration,
		messageFlowRefs = _messageFlow : MessageFlow 
	};
	checkonly domain uml _collaborationUse : uml::CollaborationUse {
		name = _name 
	};			
	--check stereotype
	checkonly domain uml _umlCallConversation : bpmnprofile::CallConversation {
		base_CollaborationUse = _collaborationUse,
		collaboration = _umlCollaboration,
		messageFlowRefs = _umlMessageFlow 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration ); 
		InformationFlowToMessageFlow( _messageFlow, _umlMessageFlow );
	}
}


relation ParticipantAssociationToDependency
--map BPMN ParticipantAssociation to UML Dependency
{
	checkonly domain bpmn _participantAssociation : ParticipantAssociation {
		collaboration = _collaboration : Collaboration 
	};
	enforce domain uml _dependency : uml::Dependency { };			
	--check stereotype
	checkonly domain uml _umlParticipantAssociation : bpmnprofile::ParticipantAssociation {
		base_Dependency = _dependency,
		collaboration = _umlCollaboration 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration );
	}
}


relation InformationFlowToConversationNode
-- map UML InformationFlow to BPMN ConversationNode
{
	enforce domain bpmn _conversationNode : ConversationNode {
		name = _name : String };
	checkonly domain uml _informationFlow : uml::InformationFlow {
		name = _name };
	--apply stereotype
	checkonly domain uml _bpmnConversationNode : bpmnprofile::ConversationNode {
		base_InformationFlow = _informationFlow	};
}


relation ConversationLinkToDependency
-- map BPMN ConversationLink to UML Dependency
{
	checkonly domain bpmn _conversationLink : ConversationLink {
		sourceRef = _sourceRef : InteractionNode,
		targetRef = _targetRef : InteractionNode };
	enforce domain uml _dependency : uml::Dependency {
		client = _umlSourceRef,
		target = _umlTargetRef };
	enforce domain uml _bpmnConversationLink : bpmnprofile::ConversationLink {
		base_Dependency = _dependency };
	where {
		InteractionNodeToElement( sourceRef, _umlSourceRef );
		InteractionNodeToElement( targetRef, _umlTargetRef );
	}
}


relation PropertyToParticipant
--map UML Property to BPMN Participant 
{
	enforce domain bpmn _participant : Participant {
		name = _name : String{},
		collaboration = _collaboration : Collaboration 
	};
	checkonly domain uml _property : uml::Property {
		name = _name,
		class = _umlClass : uml::Class 
	};
	--check stereotype
	checkonly domain uml _umlParticipant : bpmnprofile::Participant {
		base_Property = _property 
	};
	when {
		CollaborationToCollaboration( _collaboration, _umlClass );
	}
}


relation ClassToPartnerRole
--map UML Class to BPMN PartnerRole
{
	enforce domain bpmn _partnerRole : PartnerRole {
		name = _name : String{},
		participantRef = _participant : Participant 
	};
	checkonly domain uml _class : uml::Class {
		name = _name 
	};
	--check stereotype 
	checkonly domain uml _umlPartnerRole : bpmnprofile::PartnerRole {
		base_Class = _class 
	};
}

relation InstanceSpecificationToPartnerEntity
--map UML InstanceSpecification to BPMN PartnerEntity 
{
	enforce domain bpmn _partnerEntity : PartnerEntity {
		name = _name : String{},
		participantRef = _participantRef : Particpant 
	};
	checkonly domain uml _instanceSpecification : uml::InstanceSpecificatoin {
		name = _name,
		instanceValue = _instanceValue : uml::InstanceValue {
								owningProperty = _property : Property } 
	};
	--check stereotype
	checkonly domain uml _umlPartnerEntity : bpmnprofile::PartnerEntity {
		base_InstanceSpecification = _instanceSpecification 
	};
	when {
		PropertyToParticipant( _participantRef, _property );
	}
}


relation OperationToOperation
--map UML Operation to BPMN Operation
{
	enforce domain bpmn _bpmnOperation : Operation {
		name = _name : String{},
		implementationRef = _implementationRef : Element[0..1] 
	};
	checkonly domain uml _umlOperation : uml::Operation { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmnumlOperation : bpmnprofile::BPMNOperation {
		base_Operation = _umlOperation,
		implementationRef = _implementationRef 
	};
}


relation InterfaceToInterface
--map UML Interface to BPMN Interface
{
	enforce domain bpmn _bpmnInterface : Interface {
		name = _name : String{},
		implementationRef = _implementationRef : Element[0..1] 
	};
	checkonly domain uml _umlInterface : uml:: Interface{ 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _bpmnumlInterface : bpmnprofile::BPMNInterface {
		base_Interface= _umlInterface,
		implementationRef = _implementationRef 
	};
}


relation ClassToCorrelationKey
--map UML Class to BPMN CorrelationKey 
{
	enforce domain bpmn _correlationKey : CorrelationKey {
		name = _name : String{},
		collaboration = _collaboration : Collaboration,
		conversationNode = _conversationNode : ConversationNode 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCorrelationKey : bpmnprofile::CorrelationKey {
		base_Class= _class,
		collaboration = _umlCollaboration,
		conversationNode = _umlconversationNode 
	};
	where {
		CollaborationToCollaboration( _collaboration, _umlCollaboration );
	}
}


relation ClassToCorrelationSubscription
--map UML Class to BPMN CorrelationSubscription 
{
	enforce domain bpmn _correlationSubscription : CorrelationSubscription {
		name = _name : String{},
		opposite( Process.correlationSubscriptions ) = _process : Process 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCorrelationSubscription : bpmnprofile::CorrelationSubscription {
		base_Class= _class,
		opposite( BPMNProcess.correlationSubscriptions ) = _umlProcess 
	};
	where {
		ActivityToProcess( _process, _umlProcess );
	}
}



relation PropertyToCorrelationProperty
--map UML Property to BPMN CorrelationProperty 
{
	enforce domain bpmn _correlationProperty : CorrelationProperty {
		name = _name : String 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCorrelationProperty : bpmnprofile::CorrelationProperty {
		base_Property = _property 
	};
}


relation PropertyToCorrelationPropertyBinding
--map UML Property to BPMN CorrelationProperty 
{
	enforce domain bpmn _correlationPropertyBinding : CorrelationPropertyBinding {
		name = _name : String{},
		dataPath = _dataPath : FormalExpression 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCorrelationPropertyBinding : bpmnprofile::CorrelationPropertyBinding {
		base_Property = _property,
		dataPath  = _umlFormalExpression 
	};
	where {
		OpaqueExpressionToFormalExpression( _dataPath, _umlFormalExpression );
	}
}


relation PropertyToCorrelationPropertyRetrievalExpression
--map UML Property to BPMN CorrelationProperty
{
	enforce domain bpmn _correlationPropertyRetrievalExpression : 
								CorrelationPropertyRetrievalExpression {
		name = _name : String{},
		messagePath = _messagePath : FormalExpression,
		messageRef = _message : Message 
	};
	checkonly domain uml _class : uml::Class { 
		name = _name 
	};
	--check stereotype
	checkonly domain uml _umlCorrelationPropertyRetrievalExpression : 
		bpmnprofile::CorrelationPropertyRetrievalExpression {
		base_Property = _property,
		messagePath = _umlFormalExpression,
		messageRef = _umlMessage 
	};
	where {
		OpaqueExpressionToFormalExpression ( _messagePath, _umlFormalExpression );
		ClassToMessage( _message, _umlMessage );
	}
}


} --transformation
